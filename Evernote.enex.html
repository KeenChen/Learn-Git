<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="889"/>

<div>
<span><div>命令语句：</div><div><span style="color: rgb(173, 0, 0);">一、创建版本库：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>第一步：找到位置创建空目录：</div><div>$cd 目录</div><div>$ mkdir learngit</div><div>$ cd learngit   //进入当前目录</div><div>$ pwd  //显示当前目录</div><div><br/></div><div>第二步：通过<span style="color: rgb(227, 0, 0);">git init</span>命令把这个目录变成Git可以管理的仓库（初始化仓库）：</div><div>$ git init</div><div><br/></div><div>添加文件只需两步（commit可以一次提交很多文件，所以你可以多次add不同的文件）</div><div>第一步：用命令<span style="color: rgb(227, 0, 0);">git add</span>告诉Git，把文件添加到仓库（先在learngit根目录下创建一个readme.txt文件）：</div><div>$ git add readme.txt</div><div><br/></div><div>第二步：用命令<span style="color: rgb(227, 0, 0);">git commit</span>告诉Git，把文件提交到仓库：</div><div>$ git commit -m &quot;wrote a readme file&quot;  //-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</div><div><br/></div><div><img src="Evernote.enex_files/Image.png" type="image/png" style="height:auto;" width="496"/></div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">二、时间穿梭-版本回退：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git status             --掌握工作区的状态（文件是否被修改过）</div><div>git diff               --参看修改内容</div><div>git log                --显示从最近到最远的提交日志，查看提交历史，一遍确定要回退到哪个版本      //加上--pretty=oneline 使输出信息内容变简介</div><div>git reflog             --查看命令历史，以便确定要回到未来的哪个版本</div><div>git reset --hard HEAD^ --把readme.txt回退到上一个版本   //HEAD表示当前版本,上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</div><div><img src="Evernote.enex_files/Image [1].png" type="image/png" style="height:auto;" width="374"/></div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">时光穿梭--工作区和暂存区：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>把文件往Git版本库里添加的时候，是分两步执行的：</div><div><br/></div><div>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</div><div><br/></div><div>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</div><div><br/></div><div>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</div><div><img src="Evernote.enex_files/Image [2].png" type="image/png" style="height: auto;"/></div><div>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</div><div><img src="Evernote.enex_files/Image [3].png" type="image/png" style="height: auto;"/></div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">时光穿梭--管理修改：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Git跟踪并管理的是修改，而非文件.每次修改，如果不add到暂存区，那就不会加入到commit中。</div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">时光穿梭-- 撤销修改：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="color: rgb(227, 0, 0);">git checkout -- file</span>可以丢弃工作区的修改：</div><div>命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</div><div><br/></div><div>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</div><div><br/></div><div>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</div><div><br/></div><div>总之，就是让这个文件回到最近一次git commit或git add时的状态。</div><div><br/></div><div>命令<span style="color: rgb(227, 0, 0);">git reset HEAD file</span>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</div><div>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</div></div><div><br/></div><div>时光穿梭--删除文件:</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>一般情况下，通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</div></div><div><br/></div><div>三、远程仓库--添加远程库：</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</div><div>ssh-keygen -t rsa –C “youremail@example.com”  //一直enter直到没有内容</div><div><img src="Evernote.enex_files/Image [4].png" type="image/png" style="height: auto;"/> </div><div>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</div><div><br/></div><div>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。【这时会收到一份邮件确认拱腰是否错误，注意不要点击】</div><div><img src="Evernote.enex_files/Image [5].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>添加远程库：</div><div> 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</div><div><br/></div><div>首先，第一步</div><div>登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</div><div><img src="Evernote.enex_files/Image [6].png" type="image/png" style="height: auto;"/></div><div>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</div><div><img src="Evernote.enex_files/Image [7].png" type="image/png" style="height: auto;"/></div><div>目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</div><div><br/></div><div>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</div><div><br/></div><div>git remote add origin https://github.com/KeenChen/testgit.git</div><div><br/></div><div>所有的如下：</div><div><img src="Evernote.enex_files/Image [8].png" type="image/png" style="height: auto;"/></div><div>输入用户名和密码，如下：</div><div><img src="Evernote.enex_files/Image [9].png" type="image/png"/></div><div>从现在起，只要本地作了提交，就可以通过如下命令：</div><div><br/></div><div>git push origin master</div><div><br/></div><div>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">远程仓库--从远程库克隆：</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</div><div><br/></div><div>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</div><div><br/></div><div>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</div><div><img src="Evernote.enex_files/Image [10].png" type="image/png" style="height: auto;"/></div><div>如下。我们看到：<br/></div><div><img src="Evernote.enex_files/Image [11].png" type="image/png" style="height: auto;"/></div><div>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</div><div><img src="Evernote.enex_files/Image [12].png" type="image/png" style="height: auto;"/></div><div>接着在我本地目录下 生成testgit2目录了，如下所示：</div><div><img src="Evernote.enex_files/Image [13].png" type="image/png" style="height: auto;"/></div><div><br/></div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">四、分支管理-创建合并分支：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>在版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</div><div><br/></div><div>首先，我们来<u>创建dev分支，然后切换到dev分支上</u>。如下操作：</div><div><img src="Evernote.enex_files/Image [14].png" type="image/png" style="height:auto;" width="441"/></div><div><span style="color: rgb(255, 0, 0);">git checkout</span>命令加上<span style="color: rgb(255, 0, 0);">-b</span>参数表示创建并切换，相当于以下两条命令：</div><div>$ git branch dev<br/>
$ git checkout dev</div><div>Switched to branch 'dev</div><div><br/></div><div>然后，用<span style="color: rgb(255, 0, 0);">git branch</span>命令查看当前分支：</div><div>git branch命令会列出所有分支，当前分支前面会标一个*号。</div><div><br/></div><div>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行</div><div>4444444：</div><div><img src="Evernote.enex_files/Image [15].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</div><div><img src="Evernote.enex_files/Image [16].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</div><div><img src="Evernote.enex_files/Image [17].png" type="image/png" style="height: auto;"/></div><div>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</div><div><br/></div><div>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</div><div><br/></div><div>合并完成后，我们可以接着删除dev分支了，操作如下：</div><div><img src="Evernote.enex_files/Image [18].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>总结创建与合并分支命令如下：</div><div><br/></div><div>   查看分支：<span style="color: rgb(255, 0, 0);">git branch</span></div><div><br/></div><div>   创建分支：<span style="color: rgb(255, 0, 0);">git branch name</span></div><div><br/></div><div>   切换分支：<span style="color: rgb(255, 0, 0);">git checkout name</span></div><div>     </div><div>   创建+切换分支：<span style="color: rgb(255, 0, 0);">git checkout –b name</span></div><div>  </div><div>   合并某分支到当前分支：<span style="color: rgb(255, 0, 0);">git merge name</span></div><div>  </div><div>   删除分支：<span style="color: rgb(255, 0, 0);">git branch –d name</span></div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">四、分支管理--解决冲突：</span></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>先新建一个新分支，比如名字叫fenzhi，在readme.txt添加一行内容，然后提交，如下所示：</div><div><img src="Evernote.enex_files/Image [19].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>现在切换到master分支上来，改变最后一行内容，如下所示：</div><div><img src="Evernote.enex_files/Image [20].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>现在，master分支和fenzhi(feature1)分支各自都分别有新的提交，变成了这样：</div><div><img src="Evernote.enex_files/Image [21].png" type="image/png" style="height: auto;"/></div><div>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</div><div><img src="Evernote.enex_files/Image [22].png" type="image/png" style="height: auto;"/></div><div>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</div><div><img src="Evernote.enex_files/Image [23].png" type="image/png" style="height: auto;"/></div><div>现在，master分支和feature1分支变成了下图所示：</div><div><img src="Evernote.enex_files/Image [24].png" type="image/png" style="height: auto;"/></div><div>用带参数的git log也可以看到分支的合并情况：</div><div><img src="Evernote.enex_files/Image [25].png" type="image/png" style="height: auto;"/></div><div>最后，删除feature1分支：</div><div><br/></div><div><br/></div><div>小结</div><div><br/></div><div>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</div><div><br/></div><div>用git log --graph命令可以看到分支合并图。</div></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div><span style="color: rgb(173, 0, 0);">四、分支管理--分支管理策略：</span></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</div><div><br/></div><div>- 创建一个dev分支。</div><div>- 修改readme.txt内容。</div><div>- 添加到暂存区。</div><div>- 切换回主分支(master)。</div><div>- 合并dev分支，使用命令 git merge -–no-ff  -m “注释” dev</div><div>- 查看历史记录</div><div><img src="Evernote.enex_files/Image [26].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div>合并dev分支，请注意--no-ff参数，表示禁用Fast forward：</div><div>可以看到，不使用Fast forward模式，merge后就像这样：</div><div><img src="Evernote.enex_files/Image [27].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div>分支策略</div><div><br/></div><div>在实际开发中，我们应该按照几个基本原则进行分支管理：</div><div><br/></div><div>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</div><div><br/></div><div>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</div><div><br/></div><div>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</div><div>团队合作的分支看起来就像这样：</div><div><img src="Evernote.enex_files/Image [28].png" type="image/png" style="height: auto;"/></div></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div><span style="color: rgb(173, 0, 0);">四、分支管理--Bug分支：</span></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</div><div><br/></div><div>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</div><div><br/></div><div> git stash  将当前的工作现场隐藏起来</div><div><br/></div><div> git stash list  查看隐藏的工作现场列表</div><div><br/></div><div>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</div><div><br/></div><div>- git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</div><div>- 另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</div></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div><span style="color: rgb(173, 0, 0);">四、分支管理--Feature分支：</span></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>开发一个新feature，最好新建一个分支；</div><div><br/></div><div>如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除</div></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div><span style="color: rgb(173, 0, 0);">四、分支管理--多人协作：</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</div><div><br/></div><div>- 要查看远程库的信息 使用 git remote</div><div>- 要查看远程库的详细信息 使用 git remote –v</div><div><img src="Evernote.enex_files/Image [29].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">推送分支：</span></div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</div><div><br/></div><div>使用命令 git push origin master</div><div><br/></div><div>我现在的github上的readme.txt代码如下：</div><div><img src="Evernote.enex_files/Image [30].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>本地的readme.txt代码如下：</div><div><img src="Evernote.enex_files/Image [31].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</div><div><img src="Evernote.enex_files/Image [32].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</div><div><img src="Evernote.enex_files/Image [33].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>如果要推送其他分支，比如dev，就改成</div><div>$ git push origin dev</div><div><br/></div><div>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</div><div><br/></div><div>- master分支是主分支，因此要时刻与远程同步；</div><div><br/></div><div>- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</div><div><br/></div><div>- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</div><div><br/></div><div>- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div><span style="color: rgb(227, 0, 0);">抓取分支：</span></div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div>多人协作时，大家都会往master和dev分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2。</div><div>首先要把dev分支也要推送到远程去，如下：</div><div><img src="Evernote.enex_files/Image [34].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</div><div><img src="Evernote.enex_files/Image [35].png" type="image/png" style="height: auto;"/></div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div><u>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：</u></div><div><u><br/></u></div><div>你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<span style="color: rgb(255, 0, 0);">git checkout –b dev origin/dev</span></div><div><span style="color: rgb(255, 0, 0);"><br/></span></div><div><div>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</div><div><img src="Evernote.enex_files/Image [36].png" type="image/png" style="height: auto;"/></div><u><br/></u></div><div>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</div><div><img src="Evernote.enex_files/Image [37].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</div><div><img src="Evernote.enex_files/Image [38].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</div><div><img src="Evernote.enex_files/Image [39].png" type="image/png" style="height: auto;"/></div><div>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div><img src="Evernote.enex_files/Image [40].png" type="image/png" style="height: auto;"/></div><div>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</div><div><img src="Evernote.enex_files/Image [41].png" type="image/png" style="height: auto;"/></div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div><span style="color: rgb(227, 0, 0);"><br/></span></div><div>因此：多人协作工作模式一般是这样的：</div><div><br/></div><div>- 首先，可以试图用<span style="color: rgb(255, 0, 0);">git push origin branch-name</span>推送自己的修改.</div><div>- 如果推送失败，则因为远程分支比你的本地更新早，需要先用<span style="color: rgb(255, 0, 0);">git pull</span>试图合并。</div><div>- 如果合并有冲突，则需要解决冲突，并在本地提交。再用g<span style="color: rgb(255, 0, 0);">it push origin branch-name</span>推送。</div><div><br/></div><div>如果<span style="color: rgb(255, 0, 0);">git pull</span>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<span style="color: rgb(255, 0, 0);">git branch --set-upstream branch-name origin/branch-name</span></div><div><br/></div><div>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</div><div><span style="color: rgb(227, 0, 0);"><br/></span></div></div><div><br/></div><div><span style="color: rgb(173, 0, 0);">五、标签管理：</span></div><div><span style="color: rgb(173, 0, 0);"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</div><div><br/></div><div>$ git branch</div><div>* dev</div><div>  master</div><div>$ git checkout master</div><div>Switched to branch 'master'</div><div><br/></div><div>后，敲命令<span style="color: rgb(255, 0, 0);">git tag &lt;name&gt;</span>就可以打一个新标签：</div><div>$ git tag v1.0</div><div><br/></div><div>可以用命令<span style="color: rgb(255, 0, 0);">git tag</span>查看所有标签：</div><div>$ git tag</div><div>v1.0</div><div><br/></div><div>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</div><div><br/></div><div>方法是找到历史提交的commit id，然后打上就可以了：</div><div><span style="color: rgb(255, 0, 0);">$ git log --pretty=oneline --abbrev-commit</span><br/>
6a5819e merged bug fix 101<br/>
cc17032 fix bug 1017825a50 merge with no-ff<br/>
6224937 add merge<br/>
59bc1cb conflict fixed<br/>
400b400 &amp; simple<br/>
75a857c AND simple<br/>
fec145a branch test<br/>
d17efd8 remove test.txt</div><div>...</div><div><br/></div><div>- 命令<span style="color: rgb(255, 0, 0);">git push origin &lt;tagname&gt;</span>可以推送一个本地标签；</div><div><br/></div><div>- 命令<span style="color: rgb(255, 0, 0);">git push origin --tags</span>可以推送全部未推送过的本地标签；</div><div><br/></div><div>- 命令<span style="color: rgb(255, 0, 0);">git tag -d &lt;tagname&gt;</span>可以删除一个本地标签；</div><div><br/></div><div>- 命令<span style="color: rgb(255, 0, 0);">git push origin :refs/tags/&lt;tagname&gt;</span>可以删除一个远程标签</div></div><div><br/></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Git基本常用命令如下：</div><div><br/></div><div>  mkdir： XX (创建一个空目录 XX指目录名)</div><div><br/></div><div>  pwd： 显示当前目录的路径。</div><div><br/></div><div>  git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</div><div><br/></div><div>  git add XX 把xx文件添加到暂存区去。</div><div><br/></div><div>  git commit –m “XX” 提交文件 –m 后面的是注释。</div><div><br/></div><div>  git status 查看仓库状态</div><div><br/></div><div>  git diff XX 查看XX文件修改了那些内容</div><div><br/></div><div>  git log 查看历史记录</div><div><br/></div><div>  git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本</div><div><br/></div><div>  (如果想回退到100个版本，使用git reset –hard HEAD~100 )</div><div><br/></div><div>  cat XX 查看XX文件内容</div><div><br/></div><div>  git reflog 查看历史记录的版本号id</div><div><br/></div><div>  git checkout — XX 把XX文件在工作区的修改全部撤销。</div><div><br/></div><div>  git rm XX 删除XX文件</div><div><br/></div><div>  git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库</div><div><br/></div><div>  git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</div><div><br/></div><div>  git clone https://github.com/tugenhua0707/testgit 从远程库中克隆</div><div><br/></div><div>  git checkout –b dev 创建dev分支 并切换到dev分支上</div><div><br/></div><div>  git branch 查看当前所有的分支</div><div><br/></div><div>  git checkout master 切换回master分支</div><div><br/></div><div>  git merge dev 在当前的分支上合并dev分支</div><div><br/></div><div>  git branch –d dev 删除dev分支</div><div><br/></div><div>  git branch name 创建分支</div><div><br/></div><div>  git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</div><div><br/></div><div>  git stash list 查看所有被隐藏的文件列表</div><div><br/></div><div>  git stash apply 恢复被隐藏的文件，但是内容不删除</div><div><br/></div><div>  git stash drop 删除文件</div><div><br/></div><div>  git stash pop 恢复文件的同时 也删除文件</div><div><br/></div><div>  git remote 查看远程库的信息</div><div><br/></div><div>  git remote –v 查看远程库的详细信息</div><div><br/></div><div>  git push origin master Git会把master分支推送到远程库对应的远程分支上</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 